## ğŸ›¡ï¸ Quâ€™est-ce que **gVisor** ?

**gVisor** est une **sandbox de sÃ©curitÃ© pour conteneurs** dÃ©veloppÃ©e par Google. Elle agit comme une **couche dâ€™isolation supplÃ©mentaire** entre un conteneur et le noyau Linux, dans le but de :

* Limiter les appels systÃ¨me directs (syscalls),
* RÃ©duire la surface dâ€™attaque du noyau,
* PrÃ©venir les compromissions liÃ©es Ã  des vulnÃ©rabilitÃ©s kernel.

ğŸ‘‰ En gros : **le conteneur ne parle plus directement au noyau**, mais passe par gVisor, qui filtre et gÃ¨re ses appels.

---

## ğŸ” DÃ©marche de fonctionnement de **gVisor**

Imaginons un conteneur normal :

```plaintext
[ Application ] --> [ Container Runtime ] --> [ Linux Kernel ]
```

Avec gVisor :

```plaintext
[ Application ] --> [ gVisor (Sentry + Gofer) ] --> [ Linux Kernel ]
```

Ainsi, **gVisor intercepte tous les appels systÃ¨me du conteneur**, et les **exÃ©cute de maniÃ¨re contrÃ´lÃ©e**.

---

## ğŸ§± Architecture de gVisor : Deux composants clÃ©s

### 1. ğŸ§  **Sentry**

* Ã‰crit en Go.
* Câ€™est le **composant principal** de gVisor.
* Il **implÃ©mente une version restreinte du noyau Linux en espace utilisateur (user space)**.
* Il intercepte tous les appels systÃ¨me du conteneur et les **traite lui-mÃªme sans les passer au vrai noyau**, sauf si câ€™est absolument nÃ©cessaire.

#### RÃ´le :

* GÃ¨re les processus, le systÃ¨me de fichiers, la mÃ©moire, les signaux, etc.
* Joue le rÃ´le de **"kernel simulÃ©"** en user space.

---

### 2. ğŸ“¦ **Gofer**

* GÃ¨re les **opÃ©rations dâ€™I/O (entrÃ©e/sortie)**.
* Plus prÃ©cisÃ©ment, il permet Ã  Sentry dâ€™accÃ©der aux vrais fichiers du systÃ¨me de fichiers hÃ´te.
* Le Gofer fait une sorte de **proxy** entre le Sentry et le vrai systÃ¨me de fichiers (par exemple via FUSE â€“ Filesystem in Userspace).

---

## ğŸ”’ Pourquoi utiliser gVisor ?

| ProblÃ¨me                                             | Solution via gVisor                                 |
| ---------------------------------------------------- | --------------------------------------------------- |
| Un conteneur peut exploiter une vulnÃ©rabilitÃ© kernel | gVisor bloque les appels directs et simule le noyau |
| Surface dâ€™attaque trop large avec Docker classique   | RÃ©duction des appels systÃ¨me disponibles            |
| Besoin d'isolation forte sans overhead d'une VM      | Meilleur compromis performance/sÃ©curitÃ©             |

---

## âš™ï¸ Cas dâ€™utilisation

* **Multi-tenant Kubernetes clusters** (plusieurs clients ou services partagent le mÃªme cluster).
* **ExÃ©cution de code non fiable** (services SaaS, build servers, etc.).
* **ConformitÃ©** (ISO, PCI, etc.).

---

## ğŸ“Œ RÃ©sumÃ© final

> **gVisor** agit comme un **mini-noyau en user space**. Il intercepte les appels systÃ¨me dâ€™un conteneur via son composant **Sentry**, et utilise **Gofer** pour accÃ©der aux fichiers du systÃ¨me. Cela permet de **sÃ©curiser les conteneurs en les empÃªchant dâ€™interagir directement avec le noyau Linux**, offrant une sandbox puissante et lÃ©gÃ¨re.



## ğŸ–¼ï¸ **SchÃ©ma de l'architecture gVisor**

```plaintext
                    +-----------------------------+
                    |        Container App        |
                    |-----------------------------|
                    |          gVisor Sentry      | <--- Intercepte les syscalls
                    |   (kernel userspace en Go)  |
                    +-------------|---------------+
                                  |
                          IPC, RPC calls
                                  |
                    +-------------v---------------+
                    |           Gofer             | <--- GÃ¨re les accÃ¨s I/O
                    |  (FUSE, fichiers, sockets)  |
                    +-------------|---------------+
                                  |
                    +-------------v---------------+
                    |        HÃ´te Linux           |
                    |   (vrai systÃ¨me de fichiers |
                    |     et vrai noyau Linux)    |
                    +-----------------------------+
```

---

## âš™ï¸ **Exemple : utiliser gVisor dans Kubernetes**

### 1. âœ… **PrÃ©-requis** :

* Kubernetes cluster (minikube ou autre),
* Runtime compatible gVisor, comme **containerd** ou **gVisor avec runsc** (le runtime de gVisor).

### 2. ğŸ”§ **Installation de gVisor sur le nÅ“ud**

```bash
# TÃ©lÃ©charge et installe runsc (le runtime de gVisor)
curl -fsSL https://gvisor.dev/install | bash
```

Cela installe :

* `runsc` : le runtime gVisor,
* `containerd-shim-runsc-v1` : le plugin pour containerd.

---

### 3. ğŸ§© **Configurer containerd pour gVisor**

Ajoute un runtime gVisor dans `/etc/containerd/config.toml` :

```toml
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runsc]
  runtime_type = "io.containerd.runsc.v1"
```

Puis redÃ©marre containerd :

```bash
sudo systemctl restart containerd
```

---

### 4. ğŸš€ **CrÃ©er un pod Kubernetes avec gVisor**

Voici un **exemple de pod** utilisant `runsc` comme runtime :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: gvisor-pod
spec:
  runtimeClassName: gvisor
  containers:
  - name: nginx
    image: nginx
    ports:
    - containerPort: 80
```

âš ï¸ **Important** : il faut avoir un `RuntimeClass` dÃ©fini :

```yaml
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: gvisor
handler: runsc
```

CrÃ©e-le avec :

```bash
kubectl apply -f runtimeclass-gvisor.yaml
```

Puis dÃ©ploie le pod.

---

## âœ… **Avantages de cette intÃ©gration**

| Avantage       | DÃ©tail                                                        |
| -------------- | ------------------------------------------------------------- |
| + SÃ©curitÃ©     | Isolation du kernel grÃ¢ce Ã  gVisor                            |
| + LÃ©gÃ¨retÃ©     | Moins lourd qu'une VM (contrairement Ã  Kata Containers)       |
| + Transparence | Aucun changement nÃ©cessaire Ã  l'application dans le conteneur |
