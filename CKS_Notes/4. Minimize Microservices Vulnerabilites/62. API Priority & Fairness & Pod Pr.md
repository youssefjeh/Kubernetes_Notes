### üîπ 1. **API Priority and Fairness (APF)**

#### ‚û§ C‚Äôest quoi ?
C‚Äôest un m√©canisme qui g√®re **comment les requ√™tes envoy√©es √† l‚ÄôAPI Server** sont trait√©es **quand il y a trop de demandes**.

#### ‚û§ Exemple simple :
Imagine un guichet √† la banque :  
- Les **clients VIP (High Priority)** passent plus vite.
- Les **clients normaux (Low Priority)** doivent attendre un peu plus s‚Äôil y a du monde.

#### ‚û§ Composants :
- `PriorityLevelConfiguration` : D√©finit les niveaux (par ex. *High*, *Low*).
- `FlowSchema` : R√®gle qui dit **qui** a quelle priorit√© (selon les utilisateurs, namespaces, etc.)

---

### üîπ 2. **Pod Priority & Preemption**

#### ‚û§ C‚Äôest quoi ?
Quand il y a **trop de pods et pas assez de ressources (CPU/RAM)**, Kubernetes utilise ce m√©canisme pour :
- Donner la priorit√© aux **pods les plus importants**.
- √âventuellement **supprimer des pods moins prioritaires** pour faire de la place.

#### ‚û§ Exemple :
- Tu as un **pod important (High priority)** et un **pod secondaire (Low priority)**.
- S‚Äôil n‚Äôy a pas assez de place, Kubernetes peut **supprimer le pod Low** pour que le **High puisse tourner**.

#### ‚û§ √áa se configure avec :
- Un objet `PriorityClass` :
```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000
globalDefault: false
```

- Dans le pod :
```yaml
spec:
  priorityClassName: high-priority
```

---

### üîπ 3. **Diff√©rence entre API Priority et Pod Priority**

| Aspect                  | API Priority (APF)                                | Pod Priority & Preemption                         |
|-------------------------|---------------------------------------------------|---------------------------------------------------|
| √Ä quoi √ßa s‚Äôapplique ?  | **Requ√™tes API** (ex: kubectl get, create, etc.) | **Pods en cours d'ex√©cution** dans le cluster     |
| But                    | √âviter que des utilisateurs monopolisent l‚ÄôAPI    | Assurer que les pods importants tournent          |
| G√®re quoi ?            | L‚Äô**acc√®s** √† l‚ÄôAPI Kubernetes                    | L‚Äô**utilisation des ressources** du cluster       |
| Exemple                | Un admin acc√®de plus vite √† l‚ÄôAPI que les devs    | Un pod critique tourne m√™me si d‚Äôautres sont supprim√©s |

---

### ‚úÖ R√©sum√© simple

- **API Priority** : Qui acc√®de √† **l'API Kubernetes** en premier quand c‚Äôest charg√©.
- **Pod Priority** : Qui peut **utiliser les ressources du cluster** quand il y a trop de pods.




---

## üß© 1. `PriorityLevelConfiguration` YAML

Ce fichier d√©finit un **niveau de priorit√©**, par exemple `high-priority` avec un traitement imm√©diat (`Limited`) et un `low-priority` qui sera ralenti.

```yaml
apiVersion: flowcontrol.apiserver.k8s.io/v1beta3
kind: PriorityLevelConfiguration
metadata:
  name: high-priority
spec:
  type: Limited
  limited:
    assuredConcurrencyShares: 100
    limitResponse:
      type: Queue
      queuing:
        queues: 10
        handSize: 5
        queueLengthLimit: 50
```

```yaml
apiVersion: flowcontrol.apiserver.k8s.io/v1beta3
kind: PriorityLevelConfiguration
metadata:
  name: low-priority
spec:
  type: Limited
  limited:
    assuredConcurrencyShares: 10
    limitResponse:
      type: Queue
      queuing:
        queues: 5
        handSize: 1
        queueLengthLimit: 10
```

---

## üß© 2. `FlowSchema` YAML

Ce fichier dit **qui (user, groupe, namespace)** utilise quelle priorit√©. Exemple : tout ce qui vient du namespace `prod` a la priorit√© `high-priority`.

```yaml
apiVersion: flowcontrol.apiserver.k8s.io/v1beta3
kind: FlowSchema
metadata:
  name: prod-namespace-high
spec:
  priorityLevelConfiguration:
    name: high-priority
  matchingPrecedence: 1000
  distinguisherMethod:
    type: ByUser
  rules:
    - subjects:
        - kind: Group
          group:
            name: system:authenticated
      resourceRules:
        - verbs: ["*"]
          apiGroups: ["*"]
          resources: ["*"]
      namespaces: ["prod"]
```

Et pour une priorit√© basse pour d‚Äôautres namespaces :

```yaml
apiVersion: flowcontrol.apiserver.k8s.io/v1beta3
kind: FlowSchema
metadata:
  name: dev-namespace-low
spec:
  priorityLevelConfiguration:
    name: low-priority
  matchingPrecedence: 2000
  distinguisherMethod:
    type: ByUser
  rules:
    - subjects:
        - kind: Group
          group:
            name: system:authenticated
      resourceRules:
        - verbs: ["*"]
          apiGroups: ["*"]
          resources: ["*"]
      namespaces: ["dev"]
```

---

## üìù Remarques importantes

1. Ces ressources sont **g√©r√©es par l‚ÄôAPI server** lui-m√™me.
2. Le champ `assuredConcurrencyShares` sert √† d√©finir le **nombre relatif de requ√™tes concurrentes autoris√©es**.
3. `matchingPrecedence` plus **petit = plus prioritaire** dans l'ordre de correspondance.

---

Si tu veux, je peux aussi :

* Ajouter un exemple avec un `ServiceAccount` ou un `User` sp√©cifique.
* Te montrer comment tester cela avec `kubectl` et un cluster local (par ex. `kind` ou `minikube`).


