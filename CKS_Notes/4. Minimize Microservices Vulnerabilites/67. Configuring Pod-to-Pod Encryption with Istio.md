## ğŸŒ Objectif du Lab

Ã€ la fin de ce lab, tu sauras :
- Comment activer **lâ€™injection automatique dâ€™Istio** dans les namespaces
- Comment **dÃ©ployer une application** dans un maillage de service
- Comment appliquer des **rÃ¨gles de sÃ©curitÃ© avec mTLS**
- Et surtout, **comment tester** les communications entre les pods

---

## ğŸ”¹ Ã‰TAPE 1 â€“ VÃ©rifier si Istio est activÃ© dans un namespace

```bash
kubectl get ns --show-labels
```

### RÃ©sultat attendu :
```bash
default   Active   ...   istio-injection=enabled
```

### â• Explication :
- `istio-injection=enabled` veut dire que **tout pod crÃ©Ã© dans ce namespace aura automatiquement un sidecar Istio (proxy Envoy)**.
- Ce proxy est celui qui va **chiffrer/dÃ©chiffrer** le trafic entre services.

---

## ğŸ”¹ Ã‰TAPE 2 â€“ DÃ©ployer lâ€™application Hello World

```bash
kubectl apply -f https://raw.githubusercontent.com/istio/istio/refs/heads/master/samples/helloworld/helloworld.yaml
```

### â• Explication :
- Cela crÃ©e 2 versions (v1 et v2) de lâ€™application Hello World.
- Elles sâ€™exposent via un service interne Kubernetes `helloworld` sur le port **5000**.

---

## ğŸ”¹ Ã‰TAPE 3 â€“ CrÃ©er un namespace `test` et un pod `test` avec lâ€™image nginx

```bash
kubectl run test -n test --image nginx
```

### â• ScÃ©nario :
Tu joues ici **le rÃ´le dâ€™un client externe** Ã  lâ€™application Hello World. Tu veux tester si tu peux lui parler.

---

## ğŸ”¹ Ã‰TAPE 4 â€“ Tester la connexion depuis le pod `test`

```bash
kubectl exec -ti -n test test -- curl helloworld.default.svc.cluster.local:5000/hello
```

### ğŸ§  Pourquoi Ã§a marche ?
- Parce que par **dÃ©faut**, Istio **nâ€™impose pas mTLS**.
- Le pod `test` nâ€™a pas de proxy Istio, donc il envoie du trafic **en clair**.
- Hello World accepte ce trafic car **aucune rÃ¨gle stricte nâ€™est appliquÃ©e**.

---

## ğŸ”¹ Ã‰TAPE 5 â€“ Activer mTLS globalement avec `STRICT` mode

CrÃ©er ce fichier YAML :

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT
```

Puis :

```bash
kubectl apply -f peer_auth_global.yaml
```

### â• Explication :
- Tu dis Ã  Istio : Â« **DÃ©sormais, tout trafic entre pods doit Ãªtre chiffrÃ© (mTLS obligatoire)**. Â»
- Mais ton pod `test` dans `test` **nâ€™a pas de sidecar**, donc ne peut pas faire de mTLS â†’ il est **bloquÃ©**.

---

## ğŸ”¹ Ã‰TAPE 6 â€“ Tester Ã  nouveau (Ã§a Ã©choue)

```bash
kubectl exec -ti -n test test -- curl --head http://helloworld.default.svc:5000/hello
```

### RÃ©sultat :
```bash
curl: (56) Recv failure: Connection reset by peer
```

### ScÃ©nario :
Tu essaies dâ€™envoyer un message en clair vers Hello World, mais Istio dit : **â€œNon, je veux que tout soit chiffrÃ© maintenant.â€**

---

## ğŸ”¹ Ã‰TAPE 7 â€“ Activer Istio dans le namespace `test`

```bash
kubectl label ns test istio-injection=enabled
```

Puis tu recrÃ©es ton pod `test` :

```bash
kubectl run test --image=nginx -n test
```

### â• Pourquoi ?
- Ton pod `test` aura maintenant **le proxy Istio**, donc il peut **chiffrer le trafic avec mTLS**.
- Il est donc **autorisÃ© Ã  parler Ã  Hello World** Ã  nouveau.

---

## ğŸ”¹ Ã‰TAPE 8 â€“ Tester Ã  nouveau (Ã§a fonctionne maintenant)

```bash
kubectl exec -ti -n test test -- curl --head http://helloworld.default.svc:5000/hello
```

### RÃ©sultat :
```http
HTTP/1.1 200 OK
```

âœ… Tu as prouvÃ© que **le trafic chiffrÃ© (mTLS) est bien acceptÃ©**.

---

## ğŸ”¹ Ã‰TAPE 9 â€“ Supprimer Istio dans `test` pour dÃ©monstration

Tu supprimes lâ€™injection dâ€™Istio du namespace `test`.

Ensuite, ton pod ne pourra plus communiquer Ã  cause de la politique globale `STRICT`.

---

## ğŸ”¹ Ã‰TAPE 10 â€“ Appliquer une rÃ¨gle `PERMISSIVE` pour le namespace `default`

CrÃ©er ce fichier YAML :

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: default
spec:
  mtls:
    mode: PERMISSIVE
```

### â• Explication :
- Tu dis : Â« OK, dans le namespace `default`, jâ€™accepte **mTLS OU trafic non chiffrÃ©**. Â»
- Cela **remplace la politique globale STRICT** pour ce namespace uniquement.

---

## ğŸ”¹ Ã‰TAPE 11 â€“ Tester depuis pod `test` (encore sans sidecar)

```bash
kubectl exec -ti -n test test -- curl --head http://helloworld.default.svc:5000/hello
```

### RÃ©sultat :
```http
HTTP/1.1 200 OK
```

âœ… Ã‡a marche parce que Hello World **nâ€™exige plus forcÃ©ment mTLS** (mode permissif).

---

## ğŸ”¹ Ã‰TAPE 12 â€“ Appliquer la rÃ¨gle uniquement au workload Hello World

Mise Ã  jour du fichier :

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: default
spec:
  selector:
    matchLabels:
      app: helloworld
  mtls:
    mode: PERMISSIVE
```

### â• Effet :
- Seuls les **pods avec label `app: helloworld`** acceptent le trafic non-mTLS.
- Tous les autres pods restent protÃ©gÃ©s par la rÃ¨gle globale `STRICT`.

---

## ğŸ”¹ Ã‰TAPE 13 â€“ Tester avec une nouvelle app : BookInfo

```bash
kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.11/samples/bookinfo/platform/kube/bookinfo.yaml
```

### â• Ce qui se passe :
- BookInfo est dÃ©ployÃ© dans le namespace `default`.
- Mais **il ne bÃ©nÃ©ficie pas de la politique permissive**, donc :
  - Trafic non chiffrÃ© depuis pod `test` **est rejetÃ©** âœ…
  - Trafic vers Hello World **est acceptÃ©** âœ…

---

## âœ… Conclusion

Tu viens dâ€™apprendre Ã  :
- Activer/dÃ©sactiver Istio dans des namespaces
- Appliquer des rÃ¨gles globales ou spÃ©cifiques avec `PeerAuthentication`
- Tester des communications chiffrÃ©es (ou non) entre pods
- GÃ©rer les exceptions par namespace ou workload (sÃ©lecteur `matchLabels`)


---

### ğŸ” **Question :**

> Pourquoi on applique la politique `STRICT` mTLS dans le namespace **`istio-system`**, alors quâ€™on veut sÃ©curiser le trafic entre les namespaces `default` et `test` ?

---

### âœ… **RÃ©ponse courte :**

Parce que dans Istio, **les politiques globales** de sÃ©curitÃ© (comme `PeerAuthentication`) doivent Ãªtre **dÃ©finies dans le namespace `istio-system`** pour Ãªtre **appliquÃ©es Ã  tout le mesh** (câ€™est-Ã -dire Ã  **tous les namespaces** du cluster).

---

### ğŸ§  DÃ©tail technique :

Voici comment Ã§a marche :

| Politique `PeerAuthentication` | AppliquÃ©e dans le namespaceâ€¦ | Impact                                                                                   |
| ------------------------------ | ---------------------------- | ---------------------------------------------------------------------------------------- |
| Locale (namespace = `default`) | `default`                    | Ne sâ€™applique qu'aux pods de ce namespace                                                |
| Locale (namespace = `test`)    | `test`                       | Ne sâ€™applique qu'Ã  ce namespace                                                          |
| **Globale** âœ…                  | **`istio-system`**           | Sâ€™applique Ã  **tout le maillage Istio**, donc **tous les pods dans tous les namespaces** |

---

### ğŸ§ª Exemple concret :

#### Tu Ã©cris Ã§a :

```yaml
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: istio-system
spec:
  mtls:
    mode: STRICT
```

â¡ï¸ Cela veut dire : **tous les pods du mesh doivent utiliser mTLS, sauf si une rÃ¨gle plus spÃ©cifique dit autre chose**.

---

### ğŸ¤” Pourquoi ne pas la mettre dans `default` ou `test` ?

* Si tu mets cette rÃ¨gle en `default`, elle **n'affecte que les pods du namespace default**.
* Si tu veux vraiment **imposer mTLS pour tout le cluster**, il faut **la dÃ©finir dans `istio-system`**, car câ€™est lÃ  quâ€™Istio centralise les rÃ¨gles **globales**.

---

### ğŸ”„ RÃ©sumÃ© imagÃ© :

Câ€™est comme une rÃ¨gle au niveau **gouvernement (istio-system)** qui dit :

> â€œTout le monde doit porter une ceinture de sÃ©curitÃ© (mTLS) dans le pays (mesh)â€

Mais un dÃ©partement (`default` ou `test`) peut dire :

> â€œChez nous, pour certaines voitures (workloads spÃ©cifiques), on autorise les ceintures facultatives (PERMISSIVE)â€

ğŸ‘‰ **La loi locale Ã©crase la loi globale, mais seulement dans son territoire.**