## ğŸ”¶ 1. **Comment le DNS fonctionne dans Kubernetes ?**

Quand un pod veut communiquer avec un service, il utilise souvent **le nom DNS**. Par exemple :

```
backend.namespace-a.svc.cluster.local
```

ğŸ‘‰ Ce nom signifie :

* **`backend`** : nom du service
* **`namespace-a`** : namespace oÃ¹ se trouve le service
* **`svc`** : câ€™est un service Kubernetes
* **`cluster.local`** : domaine par dÃ©faut dans le cluster

Donc **nâ€™importe quel pod dans le cluster** peut rÃ©soudre ce nom DNS, mÃªme sâ€™il est **dans un namespace diffÃ©rent**.

---

## ğŸ”¶ 2. **Pourquoi ce nâ€™est pas sÃ©curisÃ© par dÃ©faut ?**

Parce que :

* **Tous les pods peuvent rÃ©soudre nâ€™importe quel nom DNS** du cluster (tant quâ€™ils connaissent le nom).
* Par exemple, un pod malveillant dans `namespace-b` peut **rÃ©soudre** (et tenter dâ€™accÃ©der Ã ) `backend.namespace-a.svc.cluster.local`.

ğŸ§¨ **ProblÃ¨me** : En environnement **multi-tenant**, on voudrait que **chaque namespace soit isolÃ©** â€” un locataire ne devrait **mÃªme pas savoir que les autres existent**.

---

## ğŸ”¶ 3. â—ï¸Donc par dÃ©faut : **Pas de forte isolation DNS entre namespaces**

Kubernetes est fait pour Ãªtre **facile Ã  connecter entre services**, pas forcÃ©ment sÃ©curisÃ© entre locataires.

Mais **dans un environnement multi-tenant**, câ€™est **un souci de sÃ©curitÃ©** !

---

## ğŸ” 4. **Comment amÃ©liorer lâ€™isolation DNS ?**

Il faut **modifier la configuration de CoreDNS** (le serveur DNS utilisÃ© par Kubernetes).

### âœ” Ã‰tapes principales :

1. **Ã‰diter la ConfigMap de CoreDNS** :

```bash
kubectl edit cm coredns -n kube-system
```

2. Cherche une section comme :

```text
. {
    ...
    kubernetes cluster.local in-addr.arpa ip6.arpa {
        fallthrough
    }
}
```

3. **Remplace `fallthrough` par `fallthrough in-namespace`** :

```text
    kubernetes cluster.local in-addr.arpa ip6.arpa {
        fallthrough in-namespace
    }
```

### â¤ RÃ©sultat :

* Si un pod dans `namespace-a` essaie de rÃ©soudre un service dans `namespace-b` : **Ã§a Ã©choue**.
* Chaque namespace **ne peut voir que ses propres services**.

---

## ğŸ§  Exemple imagÃ©

| Sans restriction DNS                                  | Avec `fallthrough in-namespace`                        |
| ----------------------------------------------------- | ------------------------------------------------------ |
| Un pod de locataire A peut **voir** les services de B | Il ne peut plus les rÃ©soudre = isolÃ©                   |
| Tous les services sont "visibles" via DNS             | Seuls les services du **mÃªme namespace** sont visibles |

---

## âœ… RÃ©sumÃ© simplifiÃ©

| Terme / Action                          | Explication simple                                               |
| --------------------------------------- | ---------------------------------------------------------------- |
| `backend.namespace-a.svc.cluster.local` | Nom complet dâ€™un service Kubernetes                              |
| DNS pas isolÃ©                           | Par dÃ©faut, tous les pods peuvent tout rÃ©soudre                  |
| Modifier CoreDNS                        | Pour restreindre DNS Ã  lâ€™intÃ©rieur dâ€™un namespace                |
| `fallthrough in-namespace`              | Directive qui **limite les rÃ©solutions DNS au namespace du pod** |



## â— Attention : On ne rÃ©sout pas un *pod*, mais un *service*

En gÃ©nÃ©ral :

* On **ne rÃ©sout pas directement un pod** par son nom DNS.
* On rÃ©sout un **service** (qui pointe vers des pods).

Exemple : si `podwfc` est un **pod**, mais pas un **service**, tu ne pourras **pas le rÃ©soudre** en DNS facilement.

â¡ï¸ Pour quâ€™un nom comme `podwfc.wfc.svc.cluster.local` fonctionne, **il faut que `podwfc` soit le nom dâ€™un service**, **pas juste un pod**.
